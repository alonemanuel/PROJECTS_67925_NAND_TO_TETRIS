from jack_tokenizer import JackTokenizer
from vm_writer import VMWriter
from symbol_table import SymbolTable

SUBROUTINE_DEC_COMP_ERR = "Compilation Error with subroutine parameter declaration!"

VAR_DEC_COMP_ERR = "Compilation Error with class variable declaration!"


class CompilationEngine:
    """
    Effects the actual compilation output. Gets its input from a JackTokenizer and
    emits its parsed structure into an output file/stream. The output is generated by a series of compilexxx()
    routines, one for every syntactic element xxx of the Jack grammar. The contract between these routines is
    that each compilexxx() routine should read the syntactic construct xxx from the input, advance() the
    tokenizer exactly beyond xxx, and output the parsing of xxx. Thus, compilexxx()may only be called if
    indeed xxx is the next syntactic element of the input.
    """
    VAR_DEC_KINDS = {'field', 'static'}
    SUBROUTINE_KINDS = {'constructor', 'function', 'method'}
    OPERATORS = {'+': 'add',
                 '-': 'sub',
                 '*': 'Math.multiply',
                 '/': 'Math.divide',
                 '&': 'and', '|': 'or',
                 '<': 'lt',
                 '>': 'gt',
                 '=': 'eq'}
    UNARY_OPERATORS = {'~', '-'}
    SEGMENT_MAP = {'var': 'local', 'static': 'static', 'field': 'this', 'argument': 'argument', None: 'ERROR'}

    def __init__(self, input_path, output_path):
        """
        Creates a new compilation engine with the
        given input and output. The next routine
        called must be compileClass().
        """
        self.tokenizer = JackTokenizer(input_path)  # tokenizer
        self._writer = VMWriter(output_path)  # vm writer
        self._symbol_table = SymbolTable()  # symbol table
        self.class_name = ''
        self.subroutine_name = ''
        self.if_idx = 0
        self.while_idx = 0

    def compile_class(self):
        """
        Compiles a complete class.
        :return:
        """
        self.advance()  # get first token
        self.get_new_class_scope()
        self.advance()  # get second token
        self.get_class_name()
        while self.has_more_tokens():
            self.advance()
            token = self.tokenizer.token
            if token in self.VAR_DEC_KINDS:
                self._compile_class_var_dec()
            elif token in self.SUBROUTINE_KINDS:
                self._compile_subroutine()
            elif token == '}':
                self._writer.close()
                return

    def has_more_tokens(self):
        """ checks if there is more tokens in the tokenizer """
        return self.tokenizer.has_more_tokens()

    def advance(self):
        """ advance the tokenizer """
        self.tokenizer.advance()

    def _compile_class_var_dec(self):
        """
        Compiles a variable declaration.
        """
        kind = self.tokenizer.token
        self.advance()
        var_type = self.tokenizer.token
        self.advance()
        name = self.tokenizer.token
        self._symbol_table.define(name, var_type, kind)
        while self.has_more_tokens():
            self.advance()
            token = self.tokenizer.token
            token_type = self.tokenizer.token_type
            if token_type != 'SYMBOL':
                name = token
                self._symbol_table.define(name, var_type, kind)
            elif token == ';':
                return
            elif token != ',':
                raise Exception(VAR_DEC_COMP_ERR)
        else:
            raise Exception(VAR_DEC_COMP_ERR)

    def _compile_subroutine(self):
        """
        Compiles a subroutine declaration.
        """
        self.start_subroutine()
        self.if_idx = 0
        self.while_idx = 0
        token = self.tokenizer.token
        if token == 'constructor':
            self.subroutine_name = token
        elif token == 'method':
            self._symbol_table.define('this', self.class_name, 'argument')
        self.advance()  # skip 'function' or 'method'
        self.advance()  # skip 'int\void etc'..
        #   the token is now the function's name
        if self.subroutine_name == 'constructor':
            self.constructor_name = self.tokenizer.token
        else:
            self.subroutine_name = self.tokenizer.token
        self.advance()
        self._compile_parameter_list()
        self.advance()
        self._compile_subroutine_body()

    def _compile_parameter_list(self):
        """
        Compiles a parameter list from a function declaration.
        :return:
        """
        symbol_type = None
        while self.has_more_tokens():
            self.advance()
            token = self.tokenizer.token
            token_type = self.tokenizer.token_type
            if token_type != 'SYMBOL':
                if symbol_type:
                    self._symbol_table.define(token, symbol_type, 'argument')
                    symbol_type = None
                else:
                    symbol_type = token
            elif token == ')':
                return
            elif token != ',':
                raise Exception(SUBROUTINE_DEC_COMP_ERR)
        else:
            raise Exception(SUBROUTINE_DEC_COMP_ERR)

    def _compile_subroutine_body(self):
        """
        Compiles a subroutine body.
        :return:
        """
        while self.has_more_tokens() and self.tokenizer.next_token == 'var':
            self.advance()
            token = self.tokenizer.token
            self.advance()
            next_token = self.tokenizer.next_token
            self._compile_subroutine_var_dec()
        if self.subroutine_name == 'constructor':
            self._write_memory_alloc()
        else:
            self._write_this_memory()
        self._compile_statements()

    def _write_memory_alloc(self):
        """ write the vm commands for allocating memory for constructor """
        func_name = self.class_name + '.' + self.constructor_name
        n_locals_var = self._symbol_table.var_count('var')
        n_locals_field = self._symbol_table.var_count('field')
        self._writer.write_function(func_name, n_locals_var)
        self._writer.write_push('constant', n_locals_field)
        self._writer.write_call('Memory.alloc', 1)
        self._writer.write_pop('pointer', 0)

    def _compile_subroutine_var_dec(self):
        """
        Compiles a subroutine variable declaration.
        :return:
        """
        symbol_type = self.tokenizer.token
        while self.has_more_tokens():
            var_name = self.tokenizer.next_token
            self._symbol_table.define(var_name, symbol_type, 'var')
            self.advance()
            self.advance()
            if self.tokenizer.token == ',':
                continue
            elif self.tokenizer.token == ';':
                # self.advance()
                return
        else:
            raise Exception("compilation error var declaration")

    def _compile_statements(self):
        """
        Compiles statements.
        :return:
        """
        while self.has_more_tokens():
            if self.tokenizer.token == 'let':
                self.compile_let()
            elif self.tokenizer.token == 'if':
                self.compile_if()
            elif self.tokenizer.token == 'while':
                self.compile_while()
            elif self.tokenizer.token == 'do':
                self.compile_do()
            elif self.tokenizer.token == 'return':
                self.compile_return()
            self.advance()
            if self.tokenizer.token == '}':
                return

    def _write_this_memory(self):
        name = self.class_name + '.' + self.subroutine_name
        self._writer.write_function(name, self._symbol_table.var_count('var'))
        if self._symbol_table.type_of('this'):
            self._writer.write_push('argument', 0)
            self._writer.write_pop('pointer', 0)

    def compile_do(self):
        """
        Compiles a do statement.
        :return:
        """
        self.advance()  # skip 'do'
        self.compile_subroutine_call()
        self._writer.write_pop('temp', 0)

    def compile_let(self):
        """
        Compiles a let statement.
        :return:
        """
        self.advance()  # skip 'let'
        token = self.tokenizer.token
        self.advance()  # skip  '[' or '='

        if self.tokenizer.token == '[':
            self.pop_arr(token)
        else:
            self.pop_var(token)

    def compile_while(self):
        """
        Compiles a while statement.
        :return:
        """
        whilabel_idx = str(self.while_idx)
        self.while_idx += 1
        self.advance()  # skip 'while'
        self._writer.write_label('WHILE_EXP' + whilabel_idx)
        self.advance()  # skip '('
        self.compile_expression()
        self.advance()
        self._writer.write_arithmetic('not')
        self._writer.write_if('WHILE_END' + whilabel_idx)
        self._compile_statements()
        self._writer.write_goto('WHILE_EXP' + whilabel_idx)
        self._writer.write_label('WHILE_END' + whilabel_idx)

    def compile_return(self):
        """
        Compiles a return statement.
        :return:
        """
        self.advance()
        if self.tokenizer.token == ';':
            self._writer.write_push('constant', 0)
        else:
            self.compile_expression()
            self.advance()
        self._writer.write_return()

    def compile_if(self):
        """
        Compiles an if statement, possibly with a trailing else clause.
        :return:
        """
        label_suf = str(self.if_idx)
        self.if_idx += 1
        self.advance()
        self.compile_expression()
        self.advance()
        self._writer.write_if('IF_TRUE' + label_suf)
        self._writer.write_goto('IF_FALSE' + label_suf)
        self._writer.write_label('IF_TRUE' + label_suf)
        self._compile_statements()
        if self.tokenizer.peek() == 'else':
            self._writer.write_goto('IF_END' + label_suf)
            self._writer.write_label('IF_FALSE' + label_suf)
            self.advance()
            self._compile_statements()
            self._writer.write_label('IF_END' + label_suf)
        else:
            self._writer.write_label('IF_FALSE' + label_suf)

    def compile_expression(self):
        """
        Compiles an expression.
        :return:
        """
        self.compile_term()
        while self.has_more_tokens():
            # self.advance()
            next_token = self.tokenizer.next_token
            if next_token in self.OPERATORS:
                self.advance()
                self.compile_binary_operation(next_token)
            # elif next_token == ')':
            #     self.advance()
            else:
                break

    def compile_term(self):
        """
        Compiles a term.
        :return:
        """
        token = self.tokenizer.token
        token_type = self.tokenizer.token_type
        if token_type == 'IDENTIFIER':
            self.compile_identifier_term(token)
        elif token_type == 'INT_CONST':
            self._writer.write_push("constant", int(token))
        elif token_type == 'STRING_CONST':
            self.compile_string_term(token)
        elif token_type == 'KEYWORD':
            self.compile_keyword_term(token)
        elif token_type == 'SYMBOL':
            self.compile_symbol_term(token)

    def compile_expression_list(self):
        """
        Compiles a (possibly empty) comma-separated list of expressions.
        :return:
        """
        pass

    def get_new_class_scope(self):
        """ initiate a new class scope """
        self._symbol_table = SymbolTable()

    def get_class_name(self):
        """ initiate class name """
        self.class_name = self.tokenizer.token

    def compile_unary_operator(self, token):
        """ compile unary operator """
        if token == '-':
            self._writer.write_arithmetic("neg")
        elif token == '~':
            self._writer.write_arithmetic("not")

    def compile_string_term(self, token):
        """ compile string term """
        esc_chars = {'\t': '\\t', '\n': '\\n', '\r': '\\r', '\b': '\\b', '\\\\': '\\'}
        for c in esc_chars:
            token = token.replace(c, esc_chars[c])
        self._writer.write_push('constant', len(token))
        self._writer.write_call('String.new', 1)
        for c in token:
            self._writer.write_push('constant', ord(c))
            self._writer.write_call('String.appendChar', 2)
        return

    def pop_var(self, token):
        """ write vm commands for poping a variable """
        self.advance()  # skip '='
        self.compile_expression()
        self.advance()
        index = self._symbol_table.index_of(token)
        segment = self.SEGMENT_MAP[self._symbol_table.kind_of(token)]
        self._writer.write_pop(segment, index)

    def compile_keyword_term(self, token):
        if token == 'this':
            self._writer.write_push('pointer', 0)
        else:
            self._writer.write_push('constant', 0)
            if token == 'true':
                self._writer.write_arithmetic('not')

    def compile_identifier_term(self, token):
        segment = self._symbol_table.kind_of(token)
        next_token = self.tokenizer.peek()
        if segment:

            if next_token == '[':
                self.push_arr(token, segment)
            elif next_token == '.':
                self.compile_subroutine_call()
                self.advance()
            else:  # local..
                index = self._symbol_table.index_of(token)
                self._writer.write_push(self.SEGMENT_MAP[segment], index)
        else:
            self.compile_subroutine_call()
            self.advance()

    def compile_symbol_term(self, token):
        if token == '(':
            self.advance()  # Skip '('
            self.compile_expression()
            self.advance()
        elif token in self.UNARY_OPERATORS:
            self.advance()
            self.compile_term()
            self.compile_unary_operator(token)
        elif token in {']', ')', ';', ','}:
            return

    def compile_binary_operation(self, token):
        operator = self.OPERATORS[token]
        self.advance()  # skip operator
        self.compile_term()
        if token == '+' and self.tokenizer.token_type == 'string_constant':
            self._writer.write_call('String.append', 2)
        elif token == '*' or token == '/':
            self._writer.write_call(operator, 2)  # Math.multiply or Math.division
        else:
            self._writer.write_arithmetic(operator)

    def compile_subroutine_call(self):
        name = self.tokenizer.token
        self.advance()  # skip name
        n_expressions = 0
        if self.tokenizer.token == '(':
            self._writer.write_push('pointer', 0)
            n_expressions = self.count_expressions() + 1  # +1 for 'this'
            name = self.class_name + '.' + name
        elif self.tokenizer.token == '.':
            self.advance()  # skip '.'
            instance_kind = self._symbol_table.kind_of(name)
            if instance_kind:
                index = self._symbol_table.index_of(name)
                name = self._symbol_table.class_of(name)
                self._writer.write_push(self.SEGMENT_MAP[instance_kind], index)
            name += '.' + self.tokenizer.token
            self.advance()  # skip to '('

            n_expressions = self.count_expressions()
            if instance_kind:
                n_expressions += 1
        self._writer.write_call(name, n_expressions)

    def count_expressions(self):
        n = 0
        while self.has_more_tokens():
            next_token = self.tokenizer.next_token
            if next_token == ')' or next_token == ';':
                return n
            else:
                n += 1
                self.advance()
                self.compile_expression()
                if self.tokenizer.next_token == ')':
                    return n
                self.advance()

    def pop_arr(self, token):
        """ write vm commands for poping an array """
        segment = self.SEGMENT_MAP[self._symbol_table.kind_of(token)]
        index = self._symbol_table.index_of(token)
        self.advance()  # skip '['
        self.compile_expression()
        self.advance()
        self._writer.write_push(segment, index)
        self._writer.write_arithmetic('add')
        self.advance()  # skip ']'
        self.advance()  # skip '='
        self.compile_expression()
        self.advance()
        self._writer.write_pop('temp', 0)
        self._writer.write_pop('pointer', 1)
        self._writer.write_push('temp', 0)
        self._writer.write_pop('that', 0)

    def push_arr(self, token, segment):
        """ write vm commands for pushing an array """
        index = self._symbol_table.index_of(token)
        self.advance()  # skip array name
        self.advance()  # skip '['
        self.compile_expression()
        self.advance()
        self._writer.write_push(self.SEGMENT_MAP[segment], index)
        self._writer.write_arithmetic('add')
        self._writer.write_pop('pointer', 1)
        self._writer.write_push('that', 0)

    def start_subroutine(self):
        """ restarting a subroutine """
        self._symbol_table.start_subroutine()
        self.subroutine_name = None
